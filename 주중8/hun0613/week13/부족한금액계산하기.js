// 테스트 1 〉	통과 (0.05ms, 33.5MB)
// 테스트 2 〉	통과 (0.04ms, 33.5MB)
// 테스트 3 〉	통과 (0.06ms, 33.5MB)
// 테스트 4 〉	통과 (0.06ms, 33.6MB)
// 테스트 5 〉	통과 (0.07ms, 33.5MB)
// 테스트 6 〉	통과 (0.07ms, 33.5MB)
// 테스트 7 〉	통과 (0.05ms, 33.4MB)
// 테스트 8 〉	통과 (0.07ms, 33.5MB)
// 테스트 9 〉	통과 (0.07ms, 33.5MB)
// 테스트 10 〉	통과 (0.07ms, 33.6MB)
// 테스트 11 〉	통과 (0.08ms, 33.5MB)
// 테스트 12 〉	통과 (0.10ms, 33.4MB)
// 테스트 13 〉	통과 (0.06ms, 33.4MB)
// 테스트 14 〉	통과 (0.06ms, 33.5MB)
// 테스트 15 〉	통과 (0.10ms, 33.5MB)
// 테스트 16 〉	통과 (0.06ms, 33.4MB)
// 테스트 17 〉	통과 (0.07ms, 33.4MB)
// 테스트 18 〉	통과 (0.08ms, 33.5MB)
// 테스트 19 〉	통과 (0.09ms, 33.6MB)
// 테스트 20 〉	통과 (0.15ms, 33.6MB)
// 테스트 21 〉	통과 (0.10ms, 33.4MB)
// 테스트 22 〉	통과 (0.16ms, 33.5MB)
// 테스트 23 〉	통과 (0.08ms, 33.5MB)


// 풀이시간 : 6분
// 점수 : 5점



function solution(price, money, count) {
    // price : 이용요금
    // money : 가지고 있는 돈
    // count : 이용횟수
    
    // n번 탈때마다 이용요금은 n * price
    
    // count번 탔을 때 현재가진돈에서 얼마가 부족한지 리턴
    // 부족하지않을때는 0 리턴
    
    
    // 일단 count를 1에서 count만큼 증가시키면서 이용요금을 money에서 차감
    // 그럼 최종 money는 돈이 부족할 시에는 음수가 되있을 것이고, 돈이 부족하지 않다면 양수일 것이다.
    // 최종 money가 음수인지 양수인지 판별해서 양수면 0을 리턴하고 음수면 절대값 씌워줘서 리턴하면 될듯
    
    let balance = money;
    
    for (let i = 1; i <= count; i++){
        balance -= price * i;
    }
    
    return balance > 0 ? 0 : Math.abs(balance);
}