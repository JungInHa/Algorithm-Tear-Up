// 실행 결과
// 테스트 1 〉	통과 (0.18ms, 33.2MB)
// 테스트 2 〉	통과 (0.16ms, 33.4MB)
// 테스트 3 〉	통과 (0.18ms, 33.4MB)
// 테스트 4 〉	통과 (0.12ms, 33.4MB)
// 테스트 5 〉	통과 (0.19ms, 33.5MB)
// 테스트 6 〉	통과 (0.21ms, 33.4MB)
// 테스트 7 〉	통과 (0.36ms, 33.4MB)
// 테스트 8 〉	통과 (0.31ms, 33.4MB)
// 테스트 9 〉	통과 (0.34ms, 33.5MB)
// 테스트 10 〉	통과 (0.23ms, 33.4MB)
// 테스트 11 〉	통과 (0.24ms, 33.4MB)
// 테스트 12 〉	통과 (0.40ms, 33.5MB)
// 테스트 13 〉	통과 (0.31ms, 33.4MB)
// 테스트 14 〉	통과 (0.36ms, 33.5MB)
// 테스트 15 〉	통과 (0.49ms, 33.5MB)
// 테스트 16 〉	통과 (0.34ms, 33.4MB)
// 테스트 17 〉	통과 (0.51ms, 33.5MB)
// 테스트 18 〉	통과 (0.59ms, 33.5MB)
// 테스트 19 〉	통과 (0.37ms, 33.5MB)
// 테스트 20 〉	통과 (0.56ms, 33.4MB)

// 풀이 시간 : 1시간 10분
// 점수 : 5점




function solution(survey, choices) {
    // survey : 성격유형 검사 지표 모음
    // choices : 검사자가 선택한 i+1번째(1~) 질문의 선택지
    
    // choices의 점수는 
    // 1 : 매우 비동의
    // 2 : 비동의
    // 3 : 약간 비동의
    // 4 : 모르겠음
    // 5 : 약간 동의
    // 6 : 동의
    // 7 : 매우 동의
    
    // 부정적 의견 : survey의 원소 중 앞의 지표에 점수 부여 (매우 비동의 : 3, 비동의 : 2, 약간 비동의 : 1)
        // 3점 이하
    // 긍정적 의견 : survey의 원소 중 뒤의 지표에 점수 부여 (매우 동의 : 3, 동의 : 2, 약간 동의 : 1)
        // 5점 이상
    
    // 가장 점수를 많이 획득한 유형 순으로 4자리인데
    // 만약 점수가 같다면 사전순으로 빠른 지표 선택
    
    // --- 접근 ---
    
    // 객체형태로 데이터베이스를 만들자
    
    // 점수를 획득한 지표는 객체에 키값으로 value는 획득한 점수로 누적
    
    // 총점이 큰 순서대로 4개를 배열에다 푸쉬할껀데
    // 만약 같으면 사전순으로 빠른거 푸쉬
    
    let answer = [];
    let dataObj = {
        "R" : 0,
        "T" : 0,
        "C" : 0,
        "F" : 0,
        "J" : 0,
        "M" : 0,
        "A" : 0,
        "N" : 0,
    };
    
    // 모든 종류의 지표를 하나의 배열로 만든다.
    let testCase = [
        ["R", "T"],
        ["C", "F"],
        ["J", "M"],
        ["A", "N"],
    ]
    
    
    
    for (let i = 0; i < survey.length; i++){
        if (choices[i] <= 3){
            dataObj[survey[i][0]] = dataObj[survey[i][0]] + (4 - choices[i]) 
        }else if (choices[i] >= 5){
            dataObj[survey[i][1]] = dataObj[survey[i][1]] + (choices[i] - 4)
        }
    }
    
    
    testCase.forEach(el => {
        if (dataObj[el[0]] === dataObj[el[1]]){
            answer.push(el[0] > el[1] ? el[1] : el[0])
        }else if (dataObj[el[0]] > dataObj[el[1]]){
            answer.push(el[0])
        }else{
            answer.push(el[1])
        }
    })
    
    return answer.join('');
}